<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="https://github.com/kpdecker/jsdiff#readme"

    >diff (v3.2.0)</a>
</h1>
<h4>A javascript text diff implementation.</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.diff">module diff</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">diff.</span>__esModule</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.diff.Diff">
            function <span class="apidocSignatureSpan">diff.</span>Diff
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.diff.applyPatch">
            function <span class="apidocSignatureSpan">diff.</span>applyPatch
            <span class="apidocSignatureSpan">(source, uniDiff)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.diff.applyPatches">
            function <span class="apidocSignatureSpan">diff.</span>applyPatches
            <span class="apidocSignatureSpan">(uniDiff, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.diff.canonicalize">
            function <span class="apidocSignatureSpan">diff.</span>canonicalize
            <span class="apidocSignatureSpan">(obj, stack, replacementStack)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.diff.convertChangesToDMP">
            function <span class="apidocSignatureSpan">diff.</span>convertChangesToDMP
            <span class="apidocSignatureSpan">(changes)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.diff.convertChangesToXML">
            function <span class="apidocSignatureSpan">diff.</span>convertChangesToXML
            <span class="apidocSignatureSpan">(changes)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.diff.createPatch">
            function <span class="apidocSignatureSpan">diff.</span>createPatch
            <span class="apidocSignatureSpan">(fileName, oldStr, newStr, oldHeader, newHeader, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.diff.createTwoFilesPatch">
            function <span class="apidocSignatureSpan">diff.</span>createTwoFilesPatch
            <span class="apidocSignatureSpan">(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.diff.diffArrays">
            function <span class="apidocSignatureSpan">diff.</span>diffArrays
            <span class="apidocSignatureSpan">(oldArr, newArr, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.diff.diffChars">
            function <span class="apidocSignatureSpan">diff.</span>diffChars
            <span class="apidocSignatureSpan">(oldStr, newStr, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.diff.diffCss">
            function <span class="apidocSignatureSpan">diff.</span>diffCss
            <span class="apidocSignatureSpan">(oldStr, newStr, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.diff.diffJson">
            function <span class="apidocSignatureSpan">diff.</span>diffJson
            <span class="apidocSignatureSpan">(oldObj, newObj, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.diff.diffLines">
            function <span class="apidocSignatureSpan">diff.</span>diffLines
            <span class="apidocSignatureSpan">(oldStr, newStr, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.diff.diffSentences">
            function <span class="apidocSignatureSpan">diff.</span>diffSentences
            <span class="apidocSignatureSpan">(oldStr, newStr, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.diff.diffTrimmedLines">
            function <span class="apidocSignatureSpan">diff.</span>diffTrimmedLines
            <span class="apidocSignatureSpan">(oldStr, newStr, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.diff.diffWords">
            function <span class="apidocSignatureSpan">diff.</span>diffWords
            <span class="apidocSignatureSpan">(oldStr, newStr, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.diff.diffWordsWithSpace">
            function <span class="apidocSignatureSpan">diff.</span>diffWordsWithSpace
            <span class="apidocSignatureSpan">(oldStr, newStr, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.diff.parsePatch">
            function <span class="apidocSignatureSpan">diff.</span>parsePatch
            <span class="apidocSignatureSpan">(uniDiff)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.diff.structuredPatch">
            function <span class="apidocSignatureSpan">diff.</span>structuredPatch
            <span class="apidocSignatureSpan">(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">diff.</span>Diff.prototype</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.diff.Diff">module diff.Diff</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.diff.Diff.Diff">
            function <span class="apidocSignatureSpan">diff.</span>Diff
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.diff.Diff.prototype">module diff.Diff.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.diff.Diff.prototype.castInput">
            function <span class="apidocSignatureSpan">diff.Diff.prototype.</span>castInput
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.diff.Diff.prototype.diff">
            function <span class="apidocSignatureSpan">diff.Diff.prototype.</span>diff
            <span class="apidocSignatureSpan">(oldString, newString)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.diff.Diff.prototype.equals">
            function <span class="apidocSignatureSpan">diff.Diff.prototype.</span>equals
            <span class="apidocSignatureSpan">(left, right)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.diff.Diff.prototype.extractCommon">
            function <span class="apidocSignatureSpan">diff.Diff.prototype.</span>extractCommon
            <span class="apidocSignatureSpan">(basePath, newString, oldString, diagonalPath)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.diff.Diff.prototype.join">
            function <span class="apidocSignatureSpan">diff.Diff.prototype.</span>join
            <span class="apidocSignatureSpan">(chars)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.diff.Diff.prototype.pushComponent">
            function <span class="apidocSignatureSpan">diff.Diff.prototype.</span>pushComponent
            <span class="apidocSignatureSpan">(components, added, removed)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.diff.Diff.prototype.removeEmpty">
            function <span class="apidocSignatureSpan">diff.Diff.prototype.</span>removeEmpty
            <span class="apidocSignatureSpan">(array)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.diff.Diff.prototype.tokenize">
            function <span class="apidocSignatureSpan">diff.Diff.prototype.</span>tokenize
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.diff" id="apidoc.module.diff">module diff</a></h1>




    <h2>
        <a href="#apidoc.element.diff.Diff" id="apidoc.element.diff.Diff">
        function <span class="apidocSignatureSpan">diff.</span>Diff
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Diff() {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.diff.applyPatch" id="apidoc.element.diff.applyPatch">
        function <span class="apidocSignatureSpan">diff.</span>applyPatch
        <span class="apidocSignatureSpan">(source, uniDiff)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function applyPatch(source, uniDiff) {
<span class="apidocCodeCommentSpan">  /*istanbul ignore start*/var /*istanbul ignore end*/options = arguments.length &#x3c;= 2 || arguments[2] === undefined ? {} : arguments
[2];

  if (typeof uniDiff === &#x27;string&#x27;) {
    uniDiff = /*istanbul ignore start*/(0, _parse.parsePatch) /*istanbul ignore end*/(uniDiff);
  }

  if (Array.isArray(uniDiff)) {
    if (uniDiff.length &#x3e; 1) {
      throw new Error(&#x27;applyPatch only works with a single input.&#x27;);
    }

    uniDiff = uniDiff[0];
  }

  // Apply the diff to the input
  var lines = source.split(/\r\n|[\n\v\f\r\x85]/),
      delimiters = source.match(/\r\n|[\n\v\f\r\x85]/g) || [],
      hunks = uniDiff.hunks,
      compareLine = options.compareLine || function (lineNumber, line, operation, patchContent) /*istanbul ignore start*/{
    return (/*istanbul ignore end*/line === patchContent
    );
  },
      errorCount = 0,
      fuzzFactor = options.fuzzFactor || 0,
      minLine = 0,
      offset = 0,
      removeEOFNL = /*istanbul ignore start*/void 0 /*istanbul ignore end*/,
      addEOFNL = /*istanbul ignore start*/void 0 /*istanbul ignore end*/;

  /**
   * Checks if the hunk exactly fits on the provided location
   */
</span>  function hunkFits(hunk, toPos) {
    for (var j = 0; j &#x3c; hunk.lines.length; j++) {
      var line = hunk.lines[j],
          operation = line[0],
          content = line.substr(1);

      if (operation === &#x27; &#x27; || operation === &#x27;-&#x27;) {
        // Context sanity check
        if (!compareLine(toPos + 1, lines[toPos], operation, content)) {
          errorCount++;

          if (errorCount &#x3e; fuzzFactor) {
            return false;
          }
        }
        toPos++;
      }
    }

    return true;
  }

  // Search best fit offsets for each hunk based on the previous ones
  for (var i = 0; i &#x3c; hunks.length; i++) {
    var hunk = hunks[i],
        maxLine = lines.length - hunk.oldLines,
        localOffset = 0,
        toPos = offset + hunk.oldStart - 1;

    var iterator = /*istanbul ignore start*/(0, _distanceIterator2[&#x27;default&#x27;]) /*istanbul ignore end*/(toPos, minLine, maxLine);

    for (; localOffset !== undefined; localOffset = iterator()) {
      if (hunkFits(hunk, toPos + localOffset)) {
        hunk.offset = offset += localOffset;
        break;
      }
    }

    if (localOffset === undefined) {
      return false;
    }

    // Set lower text limit to end of the current hunk, so next ones don&#x27;t try
    // to fit over already patched text
    minLine = hunk.offset + hunk.oldStart + hunk.oldLines;
  }

  // Apply patch hunks
  for (var _i = 0; _i &#x3c; hunks.length; _i++) {
    var _hunk = hunks[_i],
        _toPos = _hunk.offset + _hunk.newStart - 1;
    if (_hunk.newLines == 0) {
      _toPos++;
    }

    for (var j = 0; j &#x3c; _hunk.lines.length; j++) {
      var line = _hunk.lines[j],
          operation = line[0],
          content = line.substr(1),
          delimiter = _hunk.linedelimiters[j];

      if (operation === &#x27; &#x27;) {
        _toPos++;
      } else if (operation === &#x27;-&#x27;) {
        lines.splice(_toPos, 1);
        delimiters.splice(_toPos, 1);
        /* istanbul ignore else */
      } else if (operation === &#x27;+&#x27;) {
          lines.splice(_toPos, 0, content);
          delimiters.splice(_toPos, 0, delimiter);
          _toPos++;
        } else if (operation === &#x27;\\&#x27;) {
          var previousOperation = _hunk.lines[j - 1] ? _hunk.lines[j - 1][0] : null;
          if (previousOperation === &#x27;+&#x27;) {
            removeEOFNL = true;
          } else if (previousOperation === &#x27;-&#x27;) {
            addEOFNL = true;
          }
        }
    }
  }

  // Handle EOFNL insertion/removal
  if (removeEOFNL) {
    while (!lines[lines.length - 1]) {
      lines.pop();
      delimiters.pop();
    }
  } else if (addEOFNL) {
    lines.push(&#x27;&#x27;);
    delimiters.push(&#x27;\n&#x27;);
  }
  for (var _k = 0; _k &#x3c; lines.length - 1; _k++) {
    lines[_k] = lines[_k] + delimiters[_k];
  }
  return lines.join(&#x27;&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  hunks: [{
    oldStart: 1, oldLines: 3, newStart: 1, newLines: 3,
    lines: [&#x27; line2&#x27;, &#x27; line3&#x27;, &#x27;-line4&#x27;, &#x27;+line5&#x27;, &#x27;\\ No newline at end of file&#
x27;],
  }]
}
```

* `JsDiff.<span class="apidocCodeKeywordSpan">applyPatch</span>(source, patch[, options])` - applies a unified diff patch.

Return a string containing new version of provided data. `patch` may be a string diff or the output from the `parsePatch` or `structuredPatch
` methods.

The optional `options` object may have the following keys:

- `fuzzFactor`: Number of lines that are allowed to differ before rejecting a patch. Defaults to 0.
- `compareLine(lineNumber, line, operation, patchContent)`: Callback used to compare to given lines to determine if they should
be considered equal when patching. Defaults to strict equality but may be overriden to provide fuzzier comparison. Should return
 false if the lines should be rejected.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.diff.applyPatches" id="apidoc.element.diff.applyPatches">
        function <span class="apidocSignatureSpan">diff.</span>applyPatches
        <span class="apidocSignatureSpan">(uniDiff, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function applyPatches(uniDiff, options) {
  if (typeof uniDiff === &#x27;string&#x27;) {
    uniDiff = /*istanbul ignore start*/(0, _parse.parsePatch) /*istanbul ignore end*/(uniDiff);
  }

  var currentIndex = 0;
  function processIndex() {
    var index = uniDiff[currentIndex++];
    if (!index) {
      return options.complete();
    }

    options.loadFile(index, function (err, data) {
      if (err) {
        return options.complete(err);
      }

      var updatedContent = applyPatch(data, index, options);
      options.patched(index, updatedContent, function (err) {
        if (err) {
          return options.complete(err);
        }

        processIndex();
      });
    });
  }
  processIndex();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Return a string containing new version of provided data. `patch` may be a string diff or the output from the `parsePatch` or `structuredPatch
` methods.

The optional `options` object may have the following keys:

- `fuzzFactor`: Number of lines that are allowed to differ before rejecting a patch. Defaults to 0.
- `compareLine(lineNumber, line, operation, patchContent)`: Callback used to compare to given lines to determine if they should
be considered equal when patching. Defaults to strict equality but may be overriden to provide fuzzier comparison. Should return
 false if the lines should be rejected.

* `JsDiff.<span class="apidocCodeKeywordSpan">applyPatches</span>(patch, options)` - applies one or more patches.

This method will iterate over the contents of the patch and apply to data provided through callbacks. The general flow for each
patch index is:

- `options.loadFile(index, callback)` is called. The caller should then load the contents of the file and then pass that to the `
callback(err, data)` callback. Passing an `err` will terminate further patch execution.
- `options.patched(index, content, callback)` is called once the patch has been applied. `content` will be the return value from
 `applyPatch`. When it&#x27;s ready, the caller should call `callback(err)` callback. Passing an `err` will terminate further patch
 execution.

Once all patches have been applied or an error occurs, the `options.complete(err)` callback is made.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.diff.canonicalize" id="apidoc.element.diff.canonicalize">
        function <span class="apidocSignatureSpan">diff.</span>canonicalize
        <span class="apidocSignatureSpan">(obj, stack, replacementStack)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function canonicalize(obj, stack, replacementStack) {
  stack = stack || [];
  replacementStack = replacementStack || [];

  var i =<span class="apidocCodeCommentSpan"> /*istanbul ignore start*/void 0 /*istanbul ignore end*/;

  for (i = 0; i &#x3c; stack.length; i += 1) {
    if (stack[i] === obj) {
      return replacementStack[i];
    }
  }

  var canonicalizedObj = /*istanbul ignore start*/void 0 /*istanbul ignore end*/;

  if (&#x27;[object Array]&#x27; === objectPrototypeToString.call(obj)) {
    stack.push(obj);
    canonicalizedObj = new Array(obj.length);
    replacementStack.push(canonicalizedObj);
    for (i = 0; i &#x3c; obj.length; i += 1) {
      canonicalizedObj[i] = canonicalize(obj[i], stack, replacementStack);
    }
    stack.pop();
    replacementStack.pop();
    return canonicalizedObj;
  }

  if (obj &#x26;&#x26; obj.toJSON) {
    obj = obj.toJSON();
  }

  if ( /*istanbul ignore start*/(typeof /*istanbul ignore end*/obj === &#x27;undefined&#x27; ? &#x27;undefined&#x27; : _typeof(obj)) === &#x27;object&#x27; &#x26;&#x26;
obj !== null) {
    stack.push(obj);
    canonicalizedObj = {};
    replacementStack.push(canonicalizedObj);
    var sortedKeys = [],
        key = /*istanbul ignore start*/void 0 /*istanbul ignore end*/;
    for (key in obj) {
      /* istanbul ignore else */
</span>      if (obj.hasOwnProperty(key)) {
        sortedKeys.push(key);
      }
    }
    sortedKeys.sort();
    for (i = 0; i &#x3c; sortedKeys.length; i += 1) {
      key = sortedKeys[i];
      canonicalizedObj[key] = canonicalize(obj[key], stack, replacementStack);
    }
    stack.pop();
    replacementStack.pop();
  } else {
    canonicalizedObj = obj;
  }
  return canonicalizedObj;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.diff.convertChangesToDMP" id="apidoc.element.diff.convertChangesToDMP">
        function <span class="apidocSignatureSpan">diff.</span>convertChangesToDMP
        <span class="apidocSignatureSpan">(changes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function convertChangesToDMP(changes) {
  var ret = [],
      change = /*istanbul ignore start*/void 0 /*istanbul ignore end*/,
      operation = /*istanbul ignore start*/void 0 /*istanbul ignore end*/;
  for (var i = 0; i &#x3c; changes.length; i++) {
    change = changes[i];
    if (change.added) {
      operation = 1;
    } else if (change.removed) {
      operation = -1;
    } else {
      operation = 0;
    }

    ret.push([operation, change.value]);
  }
  return ret;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.diff.convertChangesToXML" id="apidoc.element.diff.convertChangesToXML">
        function <span class="apidocSignatureSpan">diff.</span>convertChangesToXML
        <span class="apidocSignatureSpan">(changes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function convertChangesToXML(changes) {
  var ret = [];
  for (var i = 0; i &#x3c; changes.length; i++) {
    var change = changes[i];
    if (change.added) {
      ret.push(&#x27;&#x3c;ins&#x3e;&#x27;);
    } else if (change.removed) {
      ret.push(&#x27;&#x3c;del&#x3e;&#x27;);
    }

    ret.push(escapeHTML(change.value));

    if (change.added) {
      ret.push(&#x27;&#x3c;/ins&#x3e;&#x27;);
    } else if (change.removed) {
      ret.push(&#x27;&#x3c;/del&#x3e;&#x27;);
    }
  }
  return ret.join(&#x27;&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.diff.createPatch" id="apidoc.element.diff.createPatch">
        function <span class="apidocSignatureSpan">diff.</span>createPatch
        <span class="apidocSignatureSpan">(fileName, oldStr, newStr, oldHeader, newHeader, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createPatch(fileName, oldStr, newStr, oldHeader, newHeader, options) {
  return createTwoFilesPatch(fileName, fileName, oldStr, newStr, oldHeader, newHeader, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* `newFileName` : String to be output in the filename section of the patch for the additions
* `oldStr` : Original string value
* `newStr` : New string value
* `oldHeader` : Additional information to include in the old file header
* `newHeader` : Additional information to include in the new file header
* `options` : An object with options. Currently, only `context` is supported and describes how many lines of context should be included
.

* `JsDiff.<span class="apidocCodeKeywordSpan">createPatch</span>(fileName, oldStr, newStr, oldHeader, newHeader)` - creates a unified
 diff patch.

Just like JsDiff.createTwoFilesPatch, but with oldFileName being equal to newFileName.


* `JsDiff.structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options)` - returns an object with an
array of hunk objects.

This method is similar to createTwoFilesPatch, but returns a data structure
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.diff.createTwoFilesPatch" id="apidoc.element.diff.createTwoFilesPatch">
        function <span class="apidocSignatureSpan">diff.</span>createTwoFilesPatch
        <span class="apidocSignatureSpan">(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createTwoFilesPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {
  var diff = structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options);

  var ret = [];
  if (oldFileName == newFileName) {
    ret.push(&#x27;Index: &#x27; + oldFileName);
  }
  ret.push(&#x27;===================================================================&#x27;);
  ret.push(&#x27;--- &#x27; + diff.oldFileName + (typeof diff.oldHeader === &#x27;undefined&#x27; ? &#x27;&#x27; : &#x27;\t&#x27; + diff.oldHeader));
  ret.push(&#x27;+++ &#x27; + diff.newFileName + (typeof diff.newHeader === &#x27;undefined&#x27; ? &#x27;&#x27; : &#x27;\t&#x27; + diff.newHeader));

  for (var i = 0; i &#x3c; diff.hunks.length; i++) {
    var hunk = diff.hunks[i];
    ret.push(&#x27;@@ -&#x27; + hunk.oldStart + &#x27;,&#x27; + hunk.oldLines + &#x27; +&#x27; + hunk.newStart + &#x27;,&#x27; + hunk.newLines + &#x27; @@&#x27;);
    ret.push.apply(ret, hunk.lines);
  }

  return ret.join(&#x27;\n&#x27;) + &#x27;\n&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Returns a list of change objects (See below).

* `JsDiff.diffArrays(oldArr, newArr[, options])` - diffs two arrays, comparing each item for strict equality (===).

Returns a list of change objects (See below).

* `JsDiff.<span class="apidocCodeKeywordSpan">createTwoFilesPatch</span>(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader
)` - creates a unified diff patch.

Parameters:
* `oldFileName` : String to be output in the filename section of the patch for the removals
* `newFileName` : String to be output in the filename section of the patch for the additions
* `oldStr` : Original string value
* `newStr` : New string value
* `oldHeader` : Additional information to include in the old file header
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.diff.diffArrays" id="apidoc.element.diff.diffArrays">
        function <span class="apidocSignatureSpan">diff.</span>diffArrays
        <span class="apidocSignatureSpan">(oldArr, newArr, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function diffArrays(oldArr, newArr, callback) {
  return arrayDiff.diff(oldArr, newArr, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Returns a list of change objects (See below).

* `JsDiff.diffJson(oldObj, newObj[, options])` - diffs two JSON objects, comparing the fields defined on each. The order of fields
, etc does not matter in this comparison.

Returns a list of change objects (See below).

* `JsDiff.<span class="apidocCodeKeywordSpan">diffArrays</span>(oldArr, newArr[, options])` - diffs two arrays, comparing each item
 for strict equality (===).

Returns a list of change objects (See below).

* `JsDiff.createTwoFilesPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader)` - creates a unified diff patch.

Parameters:
* `oldFileName` : String to be output in the filename section of the patch for the removals
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.diff.diffChars" id="apidoc.element.diff.diffChars">
        function <span class="apidocSignatureSpan">diff.</span>diffChars
        <span class="apidocSignatureSpan">(oldStr, newStr, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function diffChars(oldStr, newStr, callback) {
  return characterDiff.diff(oldStr, newStr, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
or

bower install jsdiff


## API

* `JsDiff.<span class="apidocCodeKeywordSpan">diffChars</span>(oldStr, newStr[, options])` - diffs two blocks of text, comparing
 character by character.

Returns a list of change objects (See below).

* `JsDiff.diffWords(oldStr, newStr[, options])` - diffs two blocks of text, comparing word by word, ignoring whitespace.

Returns a list of change objects (See below).
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.diff.diffCss" id="apidoc.element.diff.diffCss">
        function <span class="apidocSignatureSpan">diff.</span>diffCss
        <span class="apidocSignatureSpan">(oldStr, newStr, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function diffCss(oldStr, newStr, callback) {
  return cssDiff.diff(oldStr, newStr, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Returns a list of change objects (See below).

* `JsDiff.diffSentences(oldStr, newStr[, options])` - diffs two blocks of text, comparing sentence by sentence.

Returns a list of change objects (See below).

* `JsDiff.<span class="apidocCodeKeywordSpan">diffCss</span>(oldStr, newStr[, options])` - diffs two blocks of text, comparing CSS
 tokens.

Returns a list of change objects (See below).

* `JsDiff.diffJson(oldObj, newObj[, options])` - diffs two JSON objects, comparing the fields defined on each. The order of fields
, etc does not matter in this comparison.

Returns a list of change objects (See below).
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.diff.diffJson" id="apidoc.element.diff.diffJson">
        function <span class="apidocSignatureSpan">diff.</span>diffJson
        <span class="apidocSignatureSpan">(oldObj, newObj, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function diffJson(oldObj, newObj, options) {
  return jsonDiff.diff(oldObj, newObj, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Returns a list of change objects (See below).

* `JsDiff.diffCss(oldStr, newStr[, options])` - diffs two blocks of text, comparing CSS tokens.

Returns a list of change objects (See below).

* `JsDiff.<span class="apidocCodeKeywordSpan">diffJson</span>(oldObj, newObj[, options])` - diffs two JSON objects, comparing the
 fields defined on each. The order of fields, etc does not matter in this comparison.

Returns a list of change objects (See below).

* `JsDiff.diffArrays(oldArr, newArr[, options])` - diffs two arrays, comparing each item for strict equality (===).

Returns a list of change objects (See below).
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.diff.diffLines" id="apidoc.element.diff.diffLines">
        function <span class="apidocSignatureSpan">diff.</span>diffLines
        <span class="apidocSignatureSpan">(oldStr, newStr, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function diffLines(oldStr, newStr, callback) {
  return lineDiff.diff(oldStr, newStr, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Returns a list of change objects (See below).

* `JsDiff.diffWordsWithSpace(oldStr, newStr[, options])` - diffs two blocks of text, comparing word by word, treating whitespace
 as significant.

Returns a list of change objects (See below).

* `JsDiff.<span class="apidocCodeKeywordSpan">diffLines</span>(oldStr, newStr[, options])` - diffs two blocks of text, comparing
 line by line.

Options
* `ignoreWhitespace`: `true` to ignore leading and trailing whitespace. This is the same as `diffTrimmedLines`
* `newlineIsToken`: `true` to treat newline characters as separate tokens.  This allows for changes to the newline structure to
occur independently of the line content and to be treated as such. In general this is the more human friendly form of `diffLines
` and `diffLines` is better suited for patches and other computer friendly output.

Returns a list of change objects (See below).
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.diff.diffSentences" id="apidoc.element.diff.diffSentences">
        function <span class="apidocSignatureSpan">diff.</span>diffSentences
        <span class="apidocSignatureSpan">(oldStr, newStr, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function diffSentences(oldStr, newStr, callback) {
  return sentenceDiff.diff(oldStr, newStr, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Returns a list of change objects (See below).

* `JsDiff.diffTrimmedLines(oldStr, newStr[, options])` - diffs two blocks of text, comparing line by line, ignoring leading and
trailing whitespace.

Returns a list of change objects (See below).

* `JsDiff.<span class="apidocCodeKeywordSpan">diffSentences</span>(oldStr, newStr[, options])` - diffs two blocks of text, comparing
 sentence by sentence.

Returns a list of change objects (See below).

* `JsDiff.diffCss(oldStr, newStr[, options])` - diffs two blocks of text, comparing CSS tokens.

Returns a list of change objects (See below).
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.diff.diffTrimmedLines" id="apidoc.element.diff.diffTrimmedLines">
        function <span class="apidocSignatureSpan">diff.</span>diffTrimmedLines
        <span class="apidocSignatureSpan">(oldStr, newStr, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function diffTrimmedLines(oldStr, newStr, callback) {
  var options = /*istanbul ignore start*/(0, _params.generateOptions) /*istanbul ignore end*/(callback, { ignoreWhitespace: true
 });
  return lineDiff.diff(oldStr, newStr, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Options
* `ignoreWhitespace`: `true` to ignore leading and trailing whitespace. This is the same as `diffTrimmedLines`
* `newlineIsToken`: `true` to treat newline characters as separate tokens.  This allows for changes to the newline structure to
occur independently of the line content and to be treated as such. In general this is the more human friendly form of `diffLines
` and `diffLines` is better suited for patches and other computer friendly output.

Returns a list of change objects (See below).

* `JsDiff.<span class="apidocCodeKeywordSpan">diffTrimmedLines</span>(oldStr, newStr[, options])` - diffs two blocks of text, comparing
 line by line, ignoring leading and trailing whitespace.

Returns a list of change objects (See below).

* `JsDiff.diffSentences(oldStr, newStr[, options])` - diffs two blocks of text, comparing sentence by sentence.

Returns a list of change objects (See below).
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.diff.diffWords" id="apidoc.element.diff.diffWords">
        function <span class="apidocSignatureSpan">diff.</span>diffWords
        <span class="apidocSignatureSpan">(oldStr, newStr, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function diffWords(oldStr, newStr, callback) {
  var options = /*istanbul ignore start*/(0, _params.generateOptions) /*istanbul ignore end*/(callback, { ignoreWhitespace: true
 });
  return wordDiff.diff(oldStr, newStr, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

## API

* `JsDiff.diffChars(oldStr, newStr[, options])` - diffs two blocks of text, comparing character by character.

Returns a list of change objects (See below).

* `JsDiff.<span class="apidocCodeKeywordSpan">diffWords</span>(oldStr, newStr[, options])` - diffs two blocks of text, comparing
 word by word, ignoring whitespace.

Returns a list of change objects (See below).

* `JsDiff.diffWordsWithSpace(oldStr, newStr[, options])` - diffs two blocks of text, comparing word by word, treating whitespace
 as significant.

Returns a list of change objects (See below).
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.diff.diffWordsWithSpace" id="apidoc.element.diff.diffWordsWithSpace">
        function <span class="apidocSignatureSpan">diff.</span>diffWordsWithSpace
        <span class="apidocSignatureSpan">(oldStr, newStr, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function diffWordsWithSpace(oldStr, newStr, callback) {
  return wordDiff.diff(oldStr, newStr, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Returns a list of change objects (See below).

* `JsDiff.diffWords(oldStr, newStr[, options])` - diffs two blocks of text, comparing word by word, ignoring whitespace.

Returns a list of change objects (See below).

* `JsDiff.<span class="apidocCodeKeywordSpan">diffWordsWithSpace</span>(oldStr, newStr[, options])` - diffs two blocks of text,
comparing word by word, treating whitespace as significant.

Returns a list of change objects (See below).

* `JsDiff.diffLines(oldStr, newStr[, options])` - diffs two blocks of text, comparing line by line.

Options
* `ignoreWhitespace`: `true` to ignore leading and trailing whitespace. This is the same as `diffTrimmedLines`
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.diff.parsePatch" id="apidoc.element.diff.parsePatch">
        function <span class="apidocSignatureSpan">diff.</span>parsePatch
        <span class="apidocSignatureSpan">(uniDiff)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function parsePatch(uniDiff) {
  /*istanbul ignore start*/var /*istanbul ignore end*/options = arguments.length &#x3c;= 1 || arguments[1] === undefined ? {} : arguments
[1];

  var diffstr = uniDiff.split(/\r\n|[\n\v\f\r\x85]/),
      delimiters = uniDiff.match(/\r\n|[\n\v\f\r\x85]/g) || [],
      list = [],
      i = 0;

  function parseIndex() {
    var index = {};
    list.push(index);

    // Parse diff metadata
    while (i &#x3c; diffstr.length) {
      var line = diffstr[i];

      // File header found, end parsing diff metadata
      if (/^(\-\-\-|\+\+\+|@@)\s/.test(line)) {
        break;
      }

      // Diff index
      var header = /^(?:Index:|diff(?: -r \w+)+)\s+(.+?)\s*$/.exec(line);
      if (header) {
        index.index = header[1];
      }

      i++;
    }

    // Parse file headers if they are defined. Unified diff requires them, but
    // there&#x27;s no technical issues to have an isolated hunk without file header
    parseFileHeader(index);
    parseFileHeader(index);

    // Parse hunks
    index.hunks = [];

    while (i &#x3c; diffstr.length) {
      var _line = diffstr[i];

      if (/^(Index:|diff|\-\-\-|\+\+\+)\s/.test(_line)) {
        break;
      } else if (/^@@/.test(_line)) {
        index.hunks.push(parseHunk());
      } else if (_line &#x26;&#x26; options.strict) {
        // Ignore unexpected content unless in strict mode
        throw new Error(&#x27;Unknown line &#x27; + (i + 1) + &#x27; &#x27; + JSON.stringify(_line));
      } else {
        i++;
      }
    }
  }

  // Parses the --- and +++ headers, if none are found, no lines
  // are consumed.
  function parseFileHeader(index) {
    var headerPattern = /^(---|\+\+\+)\s+([\S ]*)(?:\t(.*?)\s*)?$/;
    var fileHeader = headerPattern.exec(diffstr[i]);
    if (fileHeader) {
      var keyPrefix = fileHeader[1] === &#x27;---&#x27; ? &#x27;old&#x27; : &#x27;new&#x27;;
      index[keyPrefix + &#x27;FileName&#x27;] = fileHeader[2];
      index[keyPrefix + &#x27;Header&#x27;] = fileHeader[3];

      i++;
    }
  }

  // Parses a hunk
  // This assumes that we are at the start of a hunk.
  function parseHunk() {
    var chunkHeaderIndex = i,
        chunkHeaderLine = diffstr[i++],
        chunkHeader = chunkHeaderLine.split(/@@ -(\d+)(?:,(\d+))? \+(\d+)(?:,(\d+))? @@/);

    var hunk = {
      oldStart: +chunkHeader[1],
      oldLines: +chunkHeader[2] || 1,
      newStart: +chunkHeader[3],
      newLines: +chunkHeader[4] || 1,
      lines: [],
      linedelimiters: []
    };

    var addCount = 0,
        removeCount = 0;
    for (; i &#x3c; diffstr.length; i++) {
      // Lines starting with &#x27;---&#x27; could be mistaken for the &#x22;remove line&#x22; operation
      // But they could be the header for the next file. Therefore prune such cases out.
      if (diffstr[i].indexOf(&#x27;--- &#x27;) === 0 &#x26;&#x26; i + 2 &#x3c; diffstr.length &#x26;&#x26; diffstr[i + 1].indexOf(&#x27;+++ &#x27;) === 0 &#x26;&#x26; diffstr[i + 2].indexOf
(&#x27;@@&#x27;) === 0) {
        break;
      }
      var operation = diffstr[i][0];

      if (operation === &#x27;+&#x27; || operation === &#x27;-&#x27; || operation === &#x27; &#x27; || operation === &#x27;\\&#x27;) {
        hunk.lines.push(diffstr[i]);
        hunk.linedelimiters.push(delimiters[i] || &#x27;\n&#x27;);

        if (operation === &#x27;+&#x27;) {
          addCount++;
        } else if (operation === &#x27;-&#x27;) {
          removeCount++;
        } else if (operation === &#x27; &#x27;) {
          addCount++;
          removeCount++;
        }
      } else {
        break;
      }
    }

    // Handle the empty block count case
    if (!addCount &#x26;&#x26; hunk.newLines === 1) {
      hunk.newLines = 0;
    }
    if (!removeCount &#x26;&#x26; hunk.oldLines === 1) {
      hunk.oldLines = 0;
    }

    // Perform optional sanity checking
    if (options.strict) {
      if (addCount !== hunk.newLines) {
        throw new Error(&#x27;Added line count did not match for hunk at line &#x27; + (chunkHeaderIndex + 1));
      }
      if (removeCount !== hunk.oldLines) {
        throw new Error(&#x27;Removed line count did not match for hunk at line &#x27; + (chunkHeaderIndex + 1));
      }
    }

    return hunk;
  }

  while (i &#x3c; diffstr.length) {
    parseIndex();
  }

  return list;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    This method will iterate over the contents of the patch and apply to data provided through callbacks. The general flow for each
 patch index is:

    - `options.loadFile(index, callback)` is called. The caller should then load the contents of the file and then pass that to
the `callback(err, data)` callback. Passing an `err` will terminate further patch execution.
    - `options.patched(index, content, callback)` is called once the patch has been applied. `content` will be the return value
from `applyPatch`. When it&#x27;s ready, the caller should call `callback(err)` callback. Passing an `err` will terminate further
 patch execution.

    Once all patches have been applied or an error occurs, the `options.complete(err)` callback is made.

* `JsDiff.<span class="apidocCodeKeywordSpan">parsePatch</span>(diffStr)` - Parses a patch into structured data

    Return a JSON object representation of the a patch, suitable for use with the `applyPatch` method. This parses to the same structure
 returned by `JsDiff.structuredPatch`.

* `convertChangesToXML(changes)` - converts a list of changes to a serialized XML format


All methods above which accept the optional `callback` method will run in sync mode when that parameter is omitted and in async
mode when supplied. This allows for larger diffs without blocking the event loop. This may be passed either directly as the final
 parameter or as the `callback` field in the `options` object.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.diff.structuredPatch" id="apidoc.element.diff.structuredPatch">
        function <span class="apidocSignatureSpan">diff.</span>structuredPatch
        <span class="apidocSignatureSpan">(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {
  if (!options) {
    options = {};
  }
  if (typeof options.context === &#x27;undefined&#x27;) {
    options.context = 4;
  }

  var diff =<span class="apidocCodeCommentSpan"> /*istanbul ignore start*/(0, _line.diffLines) /*istanbul ignore end*/(oldStr, newStr, options);
  diff.push({ value: &#x27;&#x27;, lines: [] }); // Append an empty value to make cleanup easier

  function contextLines(lines) {
    return lines.map(function (entry) {
      return &#x27; &#x27; + entry;
    });
  }

  var hunks = [];
  var oldRangeStart = 0,
      newRangeStart = 0,
      curRange = [],
      oldLine = 1,
      newLine = 1;
  /*istanbul ignore start*/
</span>  var _loop = function _loop( /*istanbul ignore end*/i) {
    var current = diff[i],
        lines = current.lines || current.value.replace(/\n$/, &#x27;&#x27;).split(&#x27;\n&#x27;);
    current.lines = lines;

    if (current.added || current.removed) {
      /*istanbul ignore start*/
      var _curRange;

      /*istanbul ignore end*/
      // If we have previous context, start with that
      if (!oldRangeStart) {
        var prev = diff[i - 1];
        oldRangeStart = oldLine;
        newRangeStart = newLine;

        if (prev) {
          curRange = options.context &#x3e; 0 ? contextLines(prev.lines.slice(-options.context)) : [];
          oldRangeStart -= curRange.length;
          newRangeStart -= curRange.length;
        }
      }

      // Output our changes
      /*istanbul ignore start*/(_curRange = /*istanbul ignore end*/curRange).push. /*istanbul ignore start*/apply /*istanbul ignore
 end*/( /*istanbul ignore start*/_curRange /*istanbul ignore end*/, /*istanbul ignore start*/_toConsumableArray( /*istanbul ignore
 end*/lines.map(function (entry) {
        return (current.added ? &#x27;+&#x27; : &#x27;-&#x27;) + entry;
      })));

      // Track the updated file position
      if (current.added) {
        newLine += lines.length;
      } else {
        oldLine += lines.length;
      }
    } else {
      // Identical context lines. Track line changes
      if (oldRangeStart) {
        // Close out any changes that have been output (or join overlapping)
        if (lines.length &#x3c;= options.context * 2 &#x26;&#x26; i &#x3c; diff.length - 2) {
          /*istanbul ignore start*/
          var _curRange2;

          /*istanbul ignore end*/
          // Overlapping
          /*istanbul ignore start*/(_curRange2 = /*istanbul ignore end*/curRange).push. /*istanbul ignore start*/apply /*istanbul
 ignore end*/( /*istanbul ignore start*/_curRange2 /*istanbul ignore end*/, /*istanbul ignore start*/_toConsumableArray( /*istanbul
 ignore end*/contextLines(lines)));
        } else {
          /*istanbul ignore start*/
          var _curRange3;

          /*istanbul ignore end*/
          // end the range and output
          var contextSize = Math.min(lines.length, options.context);
          /*istanbul ignore start*/(_curRange3 = /*istanbul ignore end*/curRange).push. /*istanbul ignore start*/apply /*istanbul
 ignore end*/( /*istanbul ignore start*/_curRange3 /*istanbul ignore end*/, /*istanbul ignore start*/_toConsumableArray( /*istanbul
 ignore end*/contextLines(lines.slice(0, contextSize))));

          var hunk = {
            oldStart: oldRangeStart,
            oldLines: oldLine - oldRangeStart + contextSize,
            newStart: newRangeStart,
            newLines: newLine - newRangeStart + contextSize,
            lines: curRange
          };
          if (i &#x3e;= diff.length - 2 &#x26;&#x26; lines.length &#x3c;= options.context) {
            // EOF is inside this hunk
            var oldEOFNewline = /\n$/.test(oldStr);
            var newEOFNewline = /\n$/.test(newStr);
            if (lines.length == 0 &#x26;&#x26; !oldEOFNewline) {
              // special case: old has no eol and no trailing context; no-nl can end up before adds
              curRange.splice(hunk.oldLines, 0, &#x27;\\ No newline at end of file&#x27;);
            } else if (!oldEOFNewline || !newEOFNewline) {
              curRange.push(&#x27;\\ No newline at end of file&#x27;);
            }
          }
          hunks.push(hunk);

          oldRangeStart = 0;
          newRange ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* `options` : An object with options. Currently, only `context` is supported and describes how many lines of context should be included
.

* `JsDiff.createPatch(fileName, oldStr, newStr, oldHeader, newHeader)` - creates a unified diff patch.

Just like JsDiff.createTwoFilesPatch, but with oldFileName being equal to newFileName.


* `JsDiff.<span class="apidocCodeKeywordSpan">structuredPatch</span>(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader
, options)` - returns an object with an array of hunk objects.

This method is similar to createTwoFilesPatch, but returns a data structure
suitable for further processing. Parameters are the same as createTwoFilesPatch. The data structure returned may look like this:

```js
{
  oldFileName: &#x27;oldfile&#x27;, newFileName: &#x27;newfile&#x27;,
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.diff.Diff" id="apidoc.module.diff.Diff">module diff.Diff</a></h1>


    <h2>
        <a href="#apidoc.element.diff.Diff.Diff" id="apidoc.element.diff.Diff.Diff">
        function <span class="apidocSignatureSpan">diff.</span>Diff
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Diff() {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.diff.Diff.prototype" id="apidoc.module.diff.Diff.prototype">module diff.Diff.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.diff.Diff.prototype.castInput" id="apidoc.element.diff.Diff.prototype.castInput">
        function <span class="apidocSignatureSpan">diff.Diff.prototype.</span>castInput
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function castInput(value) {
  return value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.diff.Diff.prototype.diff" id="apidoc.element.diff.Diff.prototype.diff">
        function <span class="apidocSignatureSpan">diff.Diff.prototype.</span>diff
        <span class="apidocSignatureSpan">(oldString, newString)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function diff(oldString, newString) {
<span class="apidocCodeCommentSpan">  /*istanbul ignore start*/var /*istanbul ignore end*/options = arguments.length &#x3c;= 2 || arguments[2] === undefined ? {} : arguments
[2];

  var callback = options.callback;
  if (typeof options === &#x27;function&#x27;) {
    callback = options;
    options = {};
  }
  this.options = options;

  var self = this;

  function done(value) {
    if (callback) {
      setTimeout(function () {
        callback(undefined, value);
      }, 0);
      return true;
    } else {
      return value;
    }
  }

  // Allow subclasses to massage the input prior to running
  oldString = this.castInput(oldString);
  newString = this.castInput(newString);

  oldString = this.removeEmpty(this.tokenize(oldString));
  newString = this.removeEmpty(this.tokenize(newString));

  var newLen = newString.length,
      oldLen = oldString.length;
  var editLength = 1;
  var maxEditLength = newLen + oldLen;
  var bestPath = [{ newPos: -1, components: [] }];

  // Seed editLength = 0, i.e. the content starts with the same values
  var oldPos = this.extractCommon(bestPath[0], newString, oldString, 0);
  if (bestPath[0].newPos + 1 &#x3e;= newLen &#x26;&#x26; oldPos + 1 &#x3e;= oldLen) {
    // Identity per the equality and tokenizer
    return done([{ value: this.join(newString), count: newString.length }]);
  }

  // Main worker method. checks all permutations of a given edit length for acceptance.
  function execEditLength() {
    for (var diagonalPath = -1 * editLength; diagonalPath &#x3c;= editLength; diagonalPath += 2) {
      var basePath = /*istanbul ignore start*/void 0 /*istanbul ignore end*/;
      var addPath = bestPath[diagonalPath - 1],
          removePath = bestPath[diagonalPath + 1],
          _oldPos = (removePath ? removePath.newPos : 0) - diagonalPath;
      if (addPath) {
        // No one else is going to attempt to use this value, clear it
        bestPath[diagonalPath - 1] = undefined;
      }

      var canAdd = addPath &#x26;&#x26; addPath.newPos + 1 &#x3c; newLen,
          canRemove = removePath &#x26;&#x26; 0 &#x3c;= _oldPos &#x26;&#x26; _oldPos &#x3c; oldLen;
      if (!canAdd &#x26;&#x26; !canRemove) {
        // If this path is a terminal then prune
        bestPath[diagonalPath] = undefined;
        continue;
      }

      // Select the diagonal that we want to branch from. We select the prior
      // path whose position in the new string is the farthest from the origin
      // and does not pass the bounds of the diff graph
      if (!canAdd || canRemove &#x26;&#x26; addPath.newPos &#x3c; removePath.newPos) {
        basePath = clonePath(removePath);
        self.pushComponent(basePath.components, undefined, true);
      } else {
        basePath = addPath; // No need to clone, we&#x27;ve pulled it from the list
        basePath.newPos++;
        self.pushComponent(basePath.components, true, undefined);
      }

      _oldPos = self.extractCommon(basePath, newString, oldString, diagonalPath);

      // If we have hit the end of both strings, then we are done
      if (basePath.newPos + 1 &#x3e;= newLen &#x26;&#x26; _oldPos + 1 &#x3e;= oldLen) {
        return done(buildValues(self, basePath.components, newString, oldString, self.useLongestToken));
      } else {
        // Otherwise track this path as a potential candidate and continue.
        bestPath[diagonalPath] = basePath;
      }
    }

    editLength++;
  }

  // Performs the length of edit iteration. Is a bit fugly as this has to support the
  // sync and async mode which is never fun. Loops over execEditLength until a value
  // is produced.
  if (callback) {
    (function exec() {
      setTimeout(function () {
        // This should not happen, but we want to be safe.
        /* istanbul ignore next */
</span>        if (editLength &#x3e; maxEditLength) {
          return callback();
        }

        if (!execEditLength()) {
          exec();
        }
      }, 0);
    })();
  } else {
    while (editLength &#x3c;= maxEditLength) {
      var ret = execEditLength();
      if (ret) {
        return ret;
      }
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.diff.Diff.prototype.equals" id="apidoc.element.diff.Diff.prototype.equals">
        function <span class="apidocSignatureSpan">diff.Diff.prototype.</span>equals
        <span class="apidocSignatureSpan">(left, right)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function equals(left, right) {
  return left === right;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.diff.Diff.prototype.extractCommon" id="apidoc.element.diff.Diff.prototype.extractCommon">
        function <span class="apidocSignatureSpan">diff.Diff.prototype.</span>extractCommon
        <span class="apidocSignatureSpan">(basePath, newString, oldString, diagonalPath)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function extractCommon(basePath, newString, oldString, diagonalPath) {
  var newLen = newString.length,
      oldLen = oldString.length,
      newPos = basePath.newPos,
      oldPos = newPos - diagonalPath,
      commonCount = 0;
  while (newPos + 1 &#x3c; newLen &#x26;&#x26; oldPos + 1 &#x3c; oldLen &#x26;&#x26; this.equals(newString[newPos + 1], oldString[oldPos + 1])) {
    newPos++;
    oldPos++;
    commonCount++;
  }

  if (commonCount) {
    basePath.components.push({ count: commonCount });
  }

  basePath.newPos = newPos;
  return oldPos;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.diff.Diff.prototype.join" id="apidoc.element.diff.Diff.prototype.join">
        function <span class="apidocSignatureSpan">diff.Diff.prototype.</span>join
        <span class="apidocSignatureSpan">(chars)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function join(chars) {
  return chars.join(&#x27;&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.diff.Diff.prototype.pushComponent" id="apidoc.element.diff.Diff.prototype.pushComponent">
        function <span class="apidocSignatureSpan">diff.Diff.prototype.</span>pushComponent
        <span class="apidocSignatureSpan">(components, added, removed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function pushComponent(components, added, removed) {
  var last = components[components.length - 1];
  if (last &#x26;&#x26; last.added === added &#x26;&#x26; last.removed === removed) {
    // We need to clone here as the component clone operation is just
    // as shallow array clone
    components[components.length - 1] = { count: last.count + 1, added: added, removed: removed };
  } else {
    components.push({ count: 1, added: added, removed: removed });
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.diff.Diff.prototype.removeEmpty" id="apidoc.element.diff.Diff.prototype.removeEmpty">
        function <span class="apidocSignatureSpan">diff.Diff.prototype.</span>removeEmpty
        <span class="apidocSignatureSpan">(array)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function removeEmpty(array) {
  var ret = [];
  for (var i = 0; i &#x3c; array.length; i++) {
    if (array[i]) {
      ret.push(array[i]);
    }
  }
  return ret;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.diff.Diff.prototype.tokenize" id="apidoc.element.diff.Diff.prototype.tokenize">
        function <span class="apidocSignatureSpan">diff.Diff.prototype.</span>tokenize
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function tokenize(value) {
  return value.split(&#x27;&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
